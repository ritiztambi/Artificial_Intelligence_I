;[12/7/2017 7:10 PM]Â Ritiz Tambi




;This function generates the exhaustive set of valid number of missionaries and cannibals
;that can travel by a boat.
;Output boat-list.
(defun boat-state-gen()
    (setf boat-list nil)
    (push '(6 0) boat-list)
    (push '(5 0) boat-list)
    (push '(5 1) boat-list)
    (push '(4 0) boat-list)
    (push '(4 1) boat-list)
    (push '(4 2) boat-list)
    (push '(3 0) boat-list)
    (push '(3 1) boat-list)
    (push '(3 2) boat-list)
    (push '(3 3) boat-list)
    (push '(2 0) boat-list)
    (push '(2 1) boat-list)
    (push '(2 2) boat-list)
    (push '(1 0) boat-list)
    (push '(1 1) boat-list)
    (push '(0 1) boat-list)
    (push '(0 2) boat-list)
    (push '(0 3) boat-list)
    (push '(0 4) boat-list)
    (push '(0 5) boat-list)
    (push '(0 6) boat-list)
    (return-from boat-state-gen boat-list))




;This function prunes the above generated list for the working of the code. It modifies the boat-list 
;to make sure that the elements on the right shore do not become negative on updating with the boat values.
;Output - newList.
 (defun prune-boat-state-gen(valueL list-boat valueR)
  (setf new-list nil)
  (setf rf (first valueR))
  (setf rs (second valueR))
  (loop 
  	(if (null list-boat) (return-from prune-boat-state-gen new-list))
  	(setf i (pop list-boat))
  	(setf ifirst (first i))
  	(setf isecond (second i))
  	(if(and(<= ifirst rf)(<= isecond rs))(push i new-list)))) 





;This function prunes the list generated by prune-boat-state-gen to ensure that the validity of 
;missionaries and cannibals remains on left and right shores. 
;Output - nList.
 (defun prune-boat-state-gen-final(valueL l-boat valueR)
 (setf nList nil)
 (loop
 	(if (null l-boat)(return-from prune-boat-state-gen-final nList))
 	(setf j (pop l-boat))
 	(if(and (>= (+ (first valueL) (first j)) (+ (second valueL) (second j))) (>= (- (first valueR) (first j)) (- (second valueR) (second j)))) (push j nList))))
    




;This function generates the heuristic value for the greedy-search.
(defun Heuristic-Val (left boat right)
(setf right (+ (first right)(second right)))
(setf boat (+ (first boat)(second boat)))
(return-from Heuristic-Val (/ (- right boat) boat)))






;This function iterates over the final valid boat states provided by boat-state-list
;and generates all possible next nodes.
;Output - node-list.
(defun node-generator (boat-state-list left right)
	(setf state-copy boat-state-list)
	(setf node-list nil)
	(loop
			(if (null state-copy)(return node-list))
			(setf new-boat (pop state-copy))
			(setf temp-left-shore left)
			(setf temp-right-shore right)
			(setf node-left-shore (list (+ (first temp-left-shore)(first new-boat)) (+ (second temp-left-shore)(second new-boat))))
			(setf node-right-shore (list (- (first temp-right-shore)(first new-boat)) (- (second temp-right-shore)(second new-boat))))
			(setf h (Heuristic-Val temp-left-shore new-boat temp-right-shore))	
			(setf node (list node-left-shore new-boat node-right-shore  h))
			(push node node-list)))






;This function performs greedy search over node-list generated by node-generator until the
;solution state is found.
(defun greedy(n)

		(setf right-shore (list n n))
		(setf left-shore (list 0 0))
		(setf boat(list 0 0))
		(setf start-state (list (list 0 0) (list 0 0) (list n n) (* 2 n)))
		(setf open nil)
		(push start-state open)
		(loop
			do
				(if (null open)(return 'failure))
				(setf node (pop open))
				(setf left-shore (first node))
				(setf right-shore (third node))
				(setf boat (second node))
				(setf miss-can (+ (first right-shore)(second right-shore)))
				(print (list 'left-shore left-shore  'right-shore right-shore))
				(if (equal 0 miss-can)(return 'goal-state-reached))
				(setf state-list (boat-state-gen))
				(setf prune-list (prune-boat-state-gen left-shore state-list right-shore))
				(setf prune-list-final (prune-boat-state-gen-final left-shore prune-list right-shore))
				(setf node-list (node-generator prune-list-final left-shore right-shore))
				(setf open (append node-list open))
				(setf open (sort open #'(lambda(node1 node2) (< (fourth node1) (fourth node2)))))))
